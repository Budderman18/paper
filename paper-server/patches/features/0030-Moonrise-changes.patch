From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bjarne Koll <git@lynxplay.dev>
Date: Tue, 8 Apr 2025 19:02:33 +0200
Subject: [PATCH] Moonrise changes


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/entity/ChunkSystemEntity.java b/ca/spottedleaf/moonrise/patches/chunk_system/entity/ChunkSystemEntity.java
index c7da23900228aab3a5673eb5adfada5091140319..10921a7702fa9a2f69d084b55a60359e93106a3b 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/entity/ChunkSystemEntity.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/entity/ChunkSystemEntity.java
@@ -3,17 +3,35 @@ package ca.spottedleaf.moonrise.patches.chunk_system.entity;
 import ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.HappyGhast;
 import net.minecraft.world.entity.monster.Shulker;
 import net.minecraft.world.entity.vehicle.AbstractMinecart;
 import net.minecraft.world.entity.vehicle.Boat;
 
 public interface ChunkSystemEntity {
 
-    public boolean moonrise$isHardColliding();
+    enum HardColliding {
+        NEVER,
+        ALWAYS,
+        SOMETIMES,
+        ;
+    }
+
+    default public boolean moonrise$isHardColliding() {
+        return switch (this.moonrise$hardCollisionConstant()) {
+            case ALWAYS -> true;
+            case NEVER -> false;
+            case SOMETIMES -> ((Entity)this).canBeCollidedWith(null);
+        };
+    }
+
+    public HardColliding moonrise$hardCollisionConstant();
 
     // for mods to override
-    public default boolean moonrise$isHardCollidingUncached() {
-        return this instanceof Boat || this instanceof AbstractMinecart || this instanceof Shulker || ((Entity)this).canBeCollidedWith();
+    public default HardColliding moonrise$computeHardCollisionConstant() {
+        if (this instanceof Boat || this instanceof AbstractMinecart || this instanceof Shulker) return HardColliding.ALWAYS;
+        if (this instanceof HappyGhast) return HardColliding.SOMETIMES;
+        return ((Entity)this).canBeCollidedWith(null) ? HardColliding.ALWAYS : HardColliding.NEVER;
     }
 
     public FullChunkStatus moonrise$getChunkStatus();
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index ba20e87d2105ce53cdaf4049de2388d05fcd1b56..77e88b2bff631d508ea875dcbdd8e2adc8e1fa48 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -14,6 +14,7 @@ import net.minecraft.nbt.Tag;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.Mth;
+import net.minecraft.util.ProblemReporter;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntitySpawnReason;
 import net.minecraft.world.entity.EntityType;
@@ -23,6 +24,8 @@ import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.entity.Visibility;
+import net.minecraft.world.level.storage.TagValueInput;
+import net.minecraft.world.level.storage.TagValueOutput;
 import net.minecraft.world.phys.AABB;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -40,6 +43,7 @@ public final class ChunkEntitySlices {
 
     private final EntityCollectionBySection allEntities;
     private final EntityCollectionBySection hardCollidingEntities;
+    private final EntityCollectionBySection sometimesHardCollidingEntities;
     private final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
     private final Reference2ObjectOpenHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
     private final EntityList entities = new EntityList();
@@ -67,6 +71,7 @@ public final class ChunkEntitySlices {
 
         this.allEntities = new EntityCollectionBySection(this);
         this.hardCollidingEntities = new EntityCollectionBySection(this);
+        this.sometimesHardCollidingEntities = new EntityCollectionBySection(this);
         this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
         this.entitiesByType = new Reference2ObjectOpenHashMap<>();
 
@@ -76,7 +81,12 @@ public final class ChunkEntitySlices {
 
     public static List<Entity> readEntities(final ServerLevel world, final CompoundTag compoundTag) {
         // TODO check this and below on update for format changes
-        return EntityType.loadEntitiesRecursive(compoundTag.getListOrEmpty("Entities"), world, EntitySpawnReason.LOAD).collect(ImmutableList.toImmutableList());
+        final net.minecraft.world.level.storage.ValueInput.ValueInputList entities = net.minecraft.world.level.storage.TagValueInput.create(
+            net.minecraft.util.ProblemReporter.DISCARDING,
+            world.registryAccess(),
+            (List<CompoundTag>) (Object) compoundTag.getListOrEmpty("Entities")
+        );
+        return EntityType.loadEntitiesRecursive(entities, world, EntitySpawnReason.LOAD).collect(ImmutableList.toImmutableList());
     }
 
     // Paper start - rewrite chunk system
@@ -116,9 +126,9 @@ public final class ChunkEntitySlices {
                 savedEntityCounts.merge(entityType, 1, Integer::sum);
             }
             // Paper end - Entity load/save limit per chunk
-            CompoundTag compoundTag = new CompoundTag();
-            if (entity.save(compoundTag)) {
-                entitiesTag.add(compoundTag);
+            TagValueOutput valueOutput = TagValueOutput.createDiscarding();
+            if (entity.save(valueOutput)) {
+                entitiesTag.add(valueOutput.buildResult());
             }
         }
         final CompoundTag ret = NbtUtils.addCurrentDataVersion(new CompoundTag());
@@ -244,8 +254,9 @@ public final class ChunkEntitySlices {
 
         this.allEntities.addEntity(entity, sectionIndex);
 
-        if (((ChunkSystemEntity)entity).moonrise$isHardColliding()) {
-            this.hardCollidingEntities.addEntity(entity, sectionIndex);
+        switch (((ChunkSystemEntity)entity).moonrise$hardCollisionConstant()) {
+            case ALWAYS -> this.hardCollidingEntities.addEntity(entity, sectionIndex);
+            case SOMETIMES -> this.sometimesHardCollidingEntities.addEntity(entity, sectionIndex);
         }
 
         for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
@@ -278,8 +289,9 @@ public final class ChunkEntitySlices {
 
         this.allEntities.removeEntity(entity, sectionIndex);
 
-        if (((ChunkSystemEntity)entity).moonrise$isHardColliding()) {
-            this.hardCollidingEntities.removeEntity(entity, sectionIndex);
+        switch (((ChunkSystemEntity)entity).moonrise$hardCollisionConstant()) {
+            case ALWAYS -> this.hardCollidingEntities.removeEntity(entity, sectionIndex);
+            case SOMETIMES -> this.sometimesHardCollidingEntities.removeEntity(entity, sectionIndex);
         }
 
         for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
@@ -299,6 +311,7 @@ public final class ChunkEntitySlices {
 
     public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
         this.hardCollidingEntities.getEntities(except, box, into, predicate);
+        this.sometimesHardCollidingEntities.getEntities(except, box, into, e -> e.moonrise$isHardColliding() && (predicate == null || predicate.test(e)));
     }
 
     public void getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index 21104ca24e73f998b127a318aeba3889f46db03a..471aa5ebc1a8782820f81fb4673a25f2655f1d96 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -378,7 +378,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
     // Paper end
     // Paper start - rewrite chunk system
-    private final boolean isHardColliding = this.moonrise$isHardCollidingUncached();
+    private final HardColliding constantHardCollision = this.moonrise$computeHardCollisionConstant();
     private net.minecraft.server.level.FullChunkStatus chunkStatus;
     private ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData chunkData;
     private int sectionX = Integer.MIN_VALUE;
@@ -387,8 +387,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     private boolean updatingSectionStatus;
 
     @Override
-    public final boolean moonrise$isHardColliding() {
-        return this.isHardColliding;
+    public final HardColliding moonrise$hardCollisionConstant() {
+        return this.constantHardCollision;
     }
 
     @Override
